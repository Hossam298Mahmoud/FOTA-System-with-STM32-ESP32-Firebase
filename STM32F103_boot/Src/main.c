/**
 ******************************************************************************
 * @file           : main.c
 * @author         : Auto-generated by STM32CubeIDE
 * @brief          : Main program body
 ******************************************************************************
 * @attention
 *
 * Copyright (c) 2025 STMicroelectronics.
 * All rights reserved.
 *
 * This software is licensed under terms that can be found in the LICENSE file
 * in the root directory of this software component.
 * If no LICENSE file comes with this software, it is provided AS-IS.
 *
 ******************************************************************************
 */

#include <stdint.h>
#include "stm32f1xx.h"
#include "gpio.h"
#include "tim.h"
#include "lcd.h"
#include <FPEC.h>
#include "constants.h"
#include "boot.h"

/*-------------------------------------------------------------*/
#if !defined(__SOFT_FP__) && defined(__ARM_FP)
  #warning "FPU is not initialized, but the project is compiling for an FPU. Please initialize the FPU before use."
#endif

void SystemInit(void)
{
	  /*--------- Enabling the HSI clock -------------*/

	/* Set the HSION bit*/
    RCC->CR |= RCC_CR_HSION;

	/* Waiting until HSI clock is ready */
	while(!(RCC->CR & RCC_CR_HSIRDY ));

	/*--------- Enabling the HSE clock -------------*/

	/* Set the HSEON bit*/
	//RCC->CR |= 1<<HSEON;

	/* Waiting until HSE clock is ready */
	//while(!(RCC->CR & 1<<HSE_RDY));

	/*-----------Select Prescaler for different Buses--------*/
	/* Select AHB prescaler to 1 */
	RCC->CFGR |= RCC_CFGR_HPRE_DIV1<<RCC_CFGR_HPRE_Pos;

	/* APB1 prescaler to 1 */
	RCC->CFGR |= RCC_CFGR_PPRE1_DIV1<<RCC_CFGR_PPRE1_Pos;

	/* APB2 prescaler to 1 */
	RCC->CFGR |= RCC_CFGR_PPRE2_DIV1<<RCC_CFGR_PPRE2_Pos;

	// System clock switch to HSI
	/*Bits 1:0 SW: System clock switch
		00: HSI oscillator selected as system clock
		01: HSE oscillator selected as system clock
		10: PLL selected as system clock
		11: not allowed
	 */
	RCC->CFGR &= ~ RCC_CFGR_SW_Msk;
	//RCC->CFGR |= RCC_CFGR_SW_HSE;   //HSE oscillator selected
}

void GPIO_Config()
{
	/* Enable the APB2 clock all GPIO port A */
	RCC->APB2ENR |= RCC_APB2ENR_IOPAEN ;
	/* Enable the APB2 clock all GPIO port B */
	RCC->APB2ENR |= RCC_APB2ENR_IOPBEN;
	/* Enable the APB2 clock all GPIO port C */
	//RCC->APB2ENR |= RCC_APB2ENR_IOPCEN ;
	GPIO_Init(GPIOA,PIN10,GPIO_OUTPUT_10MHz_PP); //PIN8 in PORTA as OUTPUT_10MHz_PP
	GPIO_Init(GPIOA,PIN8,GPIO_OUTPUT_10MHz_PP); //PIN8 in PORTA as OUTPUT_10MHz_PP
    /******************************LCD PINS*******************************************/
	GPIO_Init(GPIOB,PIN10,GPIO_OUTPUT_10MHz_PP);
	GPIO_Init(GPIOB,PIN11,GPIO_OUTPUT_10MHz_PP);
	GPIO_Init(GPIOB,PIN12,GPIO_OUTPUT_10MHz_PP);
	GPIO_Init(GPIOB,PIN13,GPIO_OUTPUT_10MHz_PP);
	GPIO_Init(GPIOB,PIN14,GPIO_OUTPUT_10MHz_PP);
	GPIO_Init(GPIOB,PIN15,GPIO_OUTPUT_10MHz_PP);
	/********************************************************************************/
	GPIO_Init(GPIOA,PIN0,GPIO_INPUT_PU_PD );   //PIN0 in PORTA as GPIO_INPUT_PU_PD
	SET_BIT(GPIOA->ODR,PIN0); //Enable pull-up Resistance for PIN0 in PORTA
	GPIO_Init(GPIOA,PIN1,GPIO_INPUT_PU_PD );   //PIN1 in PORTA as GPIO_INPUT_PU_PD
	SET_BIT(GPIOA->ODR,PIN1); //Enable pull-up Resistance for PIN1 in PORTA
}


/**********************************************************************/
volatile uint32_t system_tick_counter=0;

uint32_t GetTick()
{
	return system_tick_counter;
}

void SysTick_Handler(void)
{
	system_tick_counter++;

}
/**********************************************************************/
int main(void)
{
	/***********************Define Variables*************************************/
	//char buff[5]="";
	uint32_t start_tick=0;

	/**************************Initialization Functions***************************/
	SystemInit();
	TIM2_Init();
	Uart2_Init();
	GPIO_Config();
	LCD_Init ();
	/*****************************************************************************/
	LCD_String_xy (0, 0,">>>FOTA  DEMO<<<");
	LCD_String_xy (1, 0,"STM32 Bootloader");
	TIM2_Delay_ms(2000);
	//SysTick_Config(8000000/1000);
	//start_tick = GetTick();
    /*******************************Update Process******************************************/
	if(!GET_BIT(GPIOA->IDR, PIN0))
	{
	        /*********************1-REQEST_ACCEPT *****************/
	        SET_BIT(GPIOA->ODR,PIN10);
			LCD_Clear();
			LCD_String(" Firmware Update");
			LCD_String_xy (1, 0,"  REQEST ACCEPT  ");
			TIM2_Delay_ms(3000);
			UART2_SendChar(REQEST_ACCEPT);
			/********************************************************/
			            /******************************/
			/*********************2-Header receiving*****************/
			while(UART2_GetChar() != SEND_HEADER);
			LCD_String_xy (1, 0,"Header receiving");
			TIM2_Delay_ms(3000);
			//LCD_Clear();
			/********************************************************/
						   /******************************/
			/*********************3-Receive Header*****************/
			char head[4], ch;
			for(int i=0 ; i<4;i++)
			{
				ch=UART2_GetChar();
				//LCD_Char(ch);
				head[i]=ch;
			}
			/********************************************************/
						   /******************************/
			/*********************4-Extract Code size from Header*****************/
			uint32_t app_size = head[0] + (head[1]<<8) + (head[2]<<16) + (head[3]<<24);
			char str[12];
			itoa(app_size, str, 10);
			LCD_Clear();
			LCD_String_xy(0,3,"CODE SIZE");
			LCD_String_xy(1,5,str);
			TIM2_Delay_ms(3000);
			while(UART2_GetChar()!=FINISH_HEADER);
		/********************************************************/
						/******************************/
		/*********************5-Flash Pages Ereasing*****************/
			uint16_t num_pages= ((app_size /  PAGE_SIZE) + ((app_size %  PAGE_SIZE == 0) ? 0 : 1));
			uint16_t data, len=app_size/2;
			uint16_t* addr = (uint16_t*)APP_START_ADDRESS;
			FPEC_PagesErase(4,num_pages);
		  /********************************************************/
					  /******************************/
		/***********************6-Receive Code************************/
			LCD_Clear();
			LCD_String_xy(0,0,"Flashing Process");
			LCD_String_xy(1,4,"Waiting");
			UART2_SendChar (ACK_HEADER );
			while(UART2_GetChar() !=SEND_CODE);
		/***********************7-Flashing Process***********************/
			for(int k=0 ; k<len ; k++)
			{
				data = UART2_GetChar();
				data +=(UART2_GetChar()<<8);
				programflash(addr,data);
				addr++;
			}
			 /********************************************************/
						/******************************/
		   /*********************Updating Process Finished****************/
			while(UART2_GetChar() !=FINISH_CODE);
			UART2_SendChar (ACK_CODE );
			LCD_Clear();
			LCD_String("Updating Process");
			LCD_String_xy(1,2,"is Finished");
			TIM2_Delay_ms(2000);
			/********************************************************/
						 /******************************/
	}
	/***********************************************************************************/
	RCC->CIR = 0x00000000; //Disable all interrupts related to clock
	for (int k=0 ;k<5; k++ )
	{
		TOGGLE_BIT(GPIOA->ODR,PIN10);
		TIM2_Delay_ms(500);
	}
	/***********************************************************************************
	 * ----------------------------Jump to Application---------------------------------*
	***********************************************************************************/
	__set_MSP(*((volatile uint32_t*) APP_START_ADDRESS)); //Set the MSP
	//asm volatile("msr msp, %0" ::"r"(SRAM_END));
	SCB->VTOR = APP_START_ADDRESS; //We relocate vector table to the sector 1
	/* We are now ready to jump to the main firmware */
	uint32_t JumpAddress = *((volatile uint32_t*) (APP_START_ADDRESS + 4));
	void (*reset_handler)(void) = (void*)JumpAddress;
	CLEAR_BIT(GPIOA->ODR,PIN10);
	reset_handler();
	/**********************************************************************/

	for(;;)
	{
		if( (GetTick()-start_tick)>=500 )
		{
			TOGGLE_BIT(GPIOA->ODR,PIN10);
			start_tick = GetTick();
		}

	}
}

/***************************************************************/




